/*

	This code is copyright Owen Campbell-Moore (owencmoore@gmail.com). Please contact him with any problems or with feature requests.

	Permission is hereby granted, free of charge, to any person obtaining
	a copy of this software and associated documentation files (the
	"Software"), to deal in the Software without restriction, including
	without limitation the rights to use, copy, modify, merge, publish,
	distribute, sublicense, and/or sell copies of the Software, and to
	permit persons to whom the Software is furnished to do so, subject to
	the following conditions:

	The above copyright notice and this permission notice shall be
	included in all copies or substantial portions of the Software.

	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
	EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
	NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
	LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
	OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
	WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

*/

var AnnotatedBliss = function () {
	var path = 'symbols/';

	var renderHtml = function (blissWords) {
		// blissWords is a list of words
		var listOfWordsHtml = blissWords.map(function (word) {
			// Each word is a list of characters and an annotation
			var listOfCharImagesHtml = word.characters.map(function (character) {
				//Each character is a symbol, indicator pair
				var backgroundImage = (character.indicator && character.indicator !== "") ? 
					'style="background-image: url(\'' + path + character.indicator + '.png\')"' : 
					'';
				return '<img src="' + path + character.symbol + '.png" ' + 
					backgroundImage + ' />';
			});
			return '<div class="blissWord">' + 
				'<div class="blissCharacter">' + listOfCharImagesHtml.join('') + '</div>' + 
				'<div class="blissAnnotation">' + word.annotation + '</div>' + 
				'</div>';
		});
		var div = document.createElement('div');
		div.innerHTML = listOfWordsHtml.join('');
		div.classList.add('blissSentence');
		return div;
	};

	var pageLoaded = function () {
		// Find every clause of bliss text to render
		var elements = document.getElementsByTagName('bliss');
		console.log("Found "+elements.length+" sentences of bliss to convert.")
		// Loop through and render each
		for (var i = elements.length-1; i >= 0 ; i--) {
			var element = elements[i];
			var text = element.innerHTML;
			var className = element.className;
			// TODO: try catch
			var blissWords = JSON.parse(text);
			var div = renderHtml(blissWords);
			div.classList.add(className);
			element.parentNode.replaceChild(div, element);
		}
	}

	return {
		pageLoaded: pageLoaded
	};
};

/*

	This code provides an onReady function without jQuery.

*/

var ready = (function(){    

	var readyList,
		DOMContentLoaded,
		class2type = {};
		class2type["[object Boolean]"] = "boolean";
		class2type["[object Number]"] = "number";
		class2type["[object String]"] = "string";
		class2type["[object Function]"] = "function";
		class2type["[object Array]"] = "array";
		class2type["[object Date]"] = "date";
		class2type["[object RegExp]"] = "regexp";
		class2type["[object Object]"] = "object";

	var ReadyObj = {
		// Is the DOM ready to be used? Set to true once it occurs.
		isReady: false,
		// A counter to track how many items to wait for before
		// the ready event fires. See #6781
		readyWait: 1,
		// Hold (or release) the ready event
		holdReady: function( hold ) {
			if ( hold ) {
				ReadyObj.readyWait++;
			} else {
				ReadyObj.ready( true );
			}
		},
		// Handle when the DOM is ready
		ready: function( wait ) {
			// Either a released hold or an DOMready/load event and not yet ready
			if ( (wait === true && !--ReadyObj.readyWait) || (wait !== true && !ReadyObj.isReady) ) {
				// Make sure body exists, at least, in case IE gets a little overzealous (ticket #5443).
				if ( !document.body ) {
					return setTimeout( ReadyObj.ready, 1 );
				}

				// Remember that the DOM is ready
				ReadyObj.isReady = true;
				// If a normal DOM Ready event fired, decrement, and wait if need be
				if ( wait !== true && --ReadyObj.readyWait > 0 ) {
					return;
				}
				// If there are functions bound, to execute
				readyList.resolveWith( document, [ ReadyObj ] );

				// Trigger any bound ready events
				//if ( ReadyObj.fn.trigger ) {
				//  ReadyObj( document ).trigger( "ready" ).unbind( "ready" );
				//}
			}
		},
		bindReady: function() {
			if ( readyList ) {
				return;
			}
			readyList = ReadyObj._Deferred();

			// Catch cases where $(document).ready() is called after the
			// browser event has already occurred.
			if ( document.readyState === "complete" ) {
				// Handle it asynchronously to allow scripts the opportunity to delay ready
				return setTimeout( ReadyObj.ready, 1 );
			}

			// Mozilla, Opera and webkit nightlies currently support this event
			if ( document.addEventListener ) {
				// Use the handy event callback
				document.addEventListener( "DOMContentLoaded", DOMContentLoaded, false );
				// A fallback to window.onload, that will always work
				window.addEventListener( "load", ReadyObj.ready, false );

			// If IE event model is used
			} else if ( document.attachEvent ) {
				// ensure firing before onload,
				// maybe late but safe also for iframes
				document.attachEvent( "onreadystatechange", DOMContentLoaded );

				// A fallback to window.onload, that will always work
				window.attachEvent( "onload", ReadyObj.ready );

				// If IE and not a frame
				// continually check to see if the document is ready
				var toplevel = false;

				try {
					toplevel = window.frameElement == null;
				} catch(e) {}

				if ( document.documentElement.doScroll && toplevel ) {
					doScrollCheck();
				}
			}
		},
		_Deferred: function() {
			var // callbacks list
				callbacks = [],
				// stored [ context , args ]
				fired,
				// to avoid firing when already doing so
				firing,
				// flag to know if the deferred has been cancelled
				cancelled,
				// the deferred itself
				deferred  = {

					// done( f1, f2, ...)
					done: function() {
						if ( !cancelled ) {
							var args = arguments,
								i,
								length,
								elem,
								type,
								_fired;
							if ( fired ) {
								_fired = fired;
								fired = 0;
							}
							for ( i = 0, length = args.length; i < length; i++ ) {
								elem = args[ i ];
								type = ReadyObj.type( elem );
								if ( type === "array" ) {
									deferred.done.apply( deferred, elem );
								} else if ( type === "function" ) {
									callbacks.push( elem );
								}
							}
							if ( _fired ) {
								deferred.resolveWith( _fired[ 0 ], _fired[ 1 ] );
							}
						}
						return this;
					},

					// resolve with given context and args
					resolveWith: function( context, args ) {
						if ( !cancelled && !fired && !firing ) {
							// make sure args are available (#8421)
							args = args || [];
							firing = 1;
							try {
								while( callbacks[ 0 ] ) {
									callbacks.shift().apply( context, args );//shifts a callback, and applies it to document
								}
							}
							finally {
								fired = [ context, args ];
								firing = 0;
							}
						}
						return this;
					},

					// resolve with this as context and given arguments
					resolve: function() {
						deferred.resolveWith( this, arguments );
						return this;
					},

					// Has this deferred been resolved?
					isResolved: function() {
						return !!( firing || fired );
					},

					// Cancel
					cancel: function() {
						cancelled = 1;
						callbacks = [];
						return this;
					}
				};

			return deferred;
		},
		type: function( obj ) {
			return obj == null ?
				String( obj ) :
				class2type[ Object.prototype.toString.call(obj) ] || "object";
		}
	}
	// The DOM ready check for Internet Explorer
	function doScrollCheck() {
		if ( ReadyObj.isReady ) {
			return;
		}

		try {
			// If IE is used, use the trick by Diego Perini
			// http://javascript.nwbox.com/IEContentLoaded/
			document.documentElement.doScroll("left");
		} catch(e) {
			setTimeout( doScrollCheck, 1 );
			return;
		}

		// and execute any waiting functions
		ReadyObj.ready();
	}
	// Cleanup functions for the document ready method
	if ( document.addEventListener ) {
		DOMContentLoaded = function() {
			document.removeEventListener( "DOMContentLoaded", DOMContentLoaded, false );
			ReadyObj.ready();
		};

	} else if ( document.attachEvent ) {
		DOMContentLoaded = function() {
			// Make sure body exists, at least, in case IE gets a little overzealous (ticket #5443).
			if ( document.readyState === "complete" ) {
				document.detachEvent( "onreadystatechange", DOMContentLoaded );
				ReadyObj.ready();
			}
		};
	}
	function ready( fn ) {
		// Attach the listeners
		ReadyObj.bindReady();

		var type = ReadyObj.type( fn );

		// Add the callback
		readyList.done( fn );//readyList is result of _Deferred()
	}
	return ready;
})();

annotatedBliss = AnnotatedBliss();
ready(annotatedBliss.pageLoaded);